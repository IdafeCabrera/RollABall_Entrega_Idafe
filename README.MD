# üéÆ Roll-a-Ball Advanced Adventure Game

## üìù Descripci√≥n
Roll-a-Ball Adventure es un juego 3D desarrollado en Unity donde controlas una bola que debe recolectar anillos mientras esquiva enemigos. El juego combina elementos de plataformas, recolecci√≥n y evasi√≥n, creando una experiencia desafiante y divertida.

Este proyecto evoluciona el concepto cl√°sico de Roll-a-Ball, incorporando mec√°nicas avanzadas de juego, sistemas din√°micos de dificultad y efectos cinematogr√°ficos. Destaca por su implementaci√≥n de zonas de peligro din√°micas, efectos de tensi√≥n en la c√°mara y un sistema de audio adaptativo que mejora la inmersi√≥n del jugador.

## üéØ Objetivo del Juego
El objetivo principal es recolectar 10 anillos distribuidos por el nivel mientras evitas a los enemigos. Al recoger el √∫ltimo anillo, se activar√° una secuencia de victoria con efectos especiales y sonidos.

## üéÆ Controles y Gameplay

### Controles de Movimiento
- **W/‚Üë**: Mover hacia adelante
- **S/‚Üì**: Mover hacia atr√°s
- **A/‚Üê**: Mover hacia la izquierda
- **D/‚Üí**: Mover hacia la derecha
- **Espacio**: Saltar / Doble salto
- **Shift**: Sprint

### Control de C√°mara
- **Q**: Rotar c√°mara a la izquierda (90 grados)
- **E**: Rotar c√°mara a la derecha (90 grados)
- **R**: Inclinar c√°mara hacia arriba
- **F**: Inclinar c√°mara hacia abajo
- **Mouse Wheel**: Zoom din√°mico

## üéÆ Mec√°nicas de Juego

### Sistema de Movimiento
- Control preciso de la bola con f√≠sica realista usando Rigidbody.
- Sistema de doble salto implementado, con control a√©reo reducido para mayor desaf√≠o.
- Detecci√≥n de suelo mediante raycasting para precisi√≥n en saltos.
- Fricci√≥n ajustada para un movimiento suave.

```csharp
public class PlayerController : MonoBehaviour
{
    private bool IsGrounded;
    public float airControl = 0.5f;
    
    private void FixedUpdate()
    {
        Vector3 movement = new Vector3(moveX, 0, moveY);

        // Control diferenciado en tierra y aire
        if (IsGrounded)
        {
            rb.AddForce(movement * velocity);
        }
        else
        {
            rb.AddForce(movement * velocity * airControl);
        }
        
        // Fricci√≥n suave
        rb.velocity = new Vector3(rb.velocity.x * 0.9f, rb.velocity.y, rb.velocity.z * 0.9f);
    }
}
```

### Sistema de C√°mara
- Vista en tercera persona con rotaci√≥n controlada.
- Seguimiento suave del jugador con offset din√°mico y ajuste autom√°tico de altura basado en el terreno.
- Sistema de rotaci√≥n por pasos de 90 grados y l√≠mites verticales para mantener una vista jugable.
- Implementaci√≥n de efectos cinematogr√°ficos como shake effect, FOV din√°mico y aberraci√≥n crom√°tica en situaciones de peligro.

```csharp
public class CameraEffects : MonoBehaviour 
{
    public float baseFieldOfView = 60f;
    public float maxFovIncrease = 15f;
    public float chromaticAberrationIntensity = 1f;
    
    private void UpdateTensionEffects(float dangerLevel)
    {
        // FOV din√°mico
        Camera.main.fieldOfView = baseFieldOfView + (maxFovIncrease * dangerLevel);
        
        // Intensidad de efectos post-proceso
        chromaticAberration.intensity.value = dangerLevel * chromaticAberrationIntensity;
        
        // Shake modulado
        if(dangerLevel > 0.5f)
        {
            ApplyCameraShake(dangerLevel);
        }
    }
}
```

### Coleccionables
- **Anillos**:
  - Rotan constantemente para mejor visibilidad.
  - Emiten part√≠culas al ser recolectados y reproducen efectos de sonido.
  - Contador en pantalla (X/10).

### Enemigos

#### Enemigo Est√°tico
- Permanece en una posici√≥n fija.
- Al contacto:
  - Reproduce efectos de sonido.
  - Genera sistema de part√≠culas.
  - Reinicia la posici√≥n del jugador.
  - Mantiene el progreso de anillos recolectados.

#### Enemigo Perseguidor
- IA con pathfinding din√°mico y velocidad configurable.
- Velocidad adaptativa seg√∫n distancia al jugador y mira siempre hacia el jugador.
- Predicci√≥n de movimiento del jugador para un mayor desaf√≠o.

```csharp
public class Enemy02 : MonoBehaviour
{
    public float speed = 2.0f;
    public float range = 3.0f;
    
    void Update()
    {
        if (player != null)
        {
            // C√°lculo de direcci√≥n con predicci√≥n
            Vector3 direction = (player.transform.position - transform.position).normalized;
            
            // Movimiento suavizado
            transform.position += direction * speed * Time.deltaTime;
            
            // Rotaci√≥n fluida hacia el jugador
            transform.LookAt(player.transform);
        }
    }
}
```

### üåã Zonas de Peligro
Sistema din√°mico que modifica el comportamiento del juego:
- Modificaci√≥n en tiempo real del comportamiento de enemigos.
- Efectos visuales mediante shader personalizado.
- Sistema de part√≠culas reactivo.

```csharp
public class DangerZone : MonoBehaviour
{
    public float dangerIntensity = 1.5f;
    public Color dangerColor = Color.red;
    
    private void OnTriggerStay(Collider other)
    {
        if (other.CompareTag("Enemy"))
        {
            Enemy enemy = other.GetComponent<Enemy>();
            if (enemy != null)
            {
                // Aumentar agresividad
                enemy.speed *= dangerIntensity;
                // Activar efectos visuales
                enemy.ActivateDangerEffects(dangerColor);
            }
        }
    }
}
```

## üõ†Ô∏è Caracter√≠sticas T√©cnicas

### Sistemas Implementados
1. **GameManager**: Singleton para gesti√≥n global, control de puntuaci√≥n, sistema de victoria y gesti√≥n de estados del juego.
2. **Sistema de Audio Adaptativo**: M√∫sica din√°mica basada en situaciones del juego, sistema de capas de audio para tensi√≥n, transiciones suaves entre estados.

```csharp
public class AudioManager : MonoBehaviour
{
    private AudioSource backgroundMusic;
    private AudioSource tensionLayer;
    
    public void UpdateAudioLayers(float dangerLevel)
    {
        // Ajuste suave del volumen de capas
        backgroundMusic.volume = Mathf.Lerp(1f, 0.3f, dangerLevel);
        tensionLayer.volume = Mathf.Lerp(0f, 1f, dangerLevel);
    }
}
```

3. **Sistema de Part√≠culas**: Efectos visuales para coleccionables, impactos con enemigos y celebraci√≥n de victoria.
4. **UI/UX**: Contador de anillos recolectados, panel de victoria, interfaz minimalista y clara.

### Optimizaciones
- Uso de Object Pooling para part√≠culas y efectos.
- Sistema de LOD para modelos complejos y culling din√°mico de efectos visuales.
- Frame rate limitado a 60 FPS y VSync activado.
- Gesti√≥n eficiente de f√≠sicas y destrucci√≥n autom√°tica de efectos temporales.

### Shaders Personalizados
- Efecto de distorsi√≥n para zonas de peligro.
- Outline din√°mico para enemigos.
- Efectos de post-proceso personalizados.

## üé® Assets Utilizados
- Modelos 3D: Blender para anillos y obst√°culos.
- Texturas: Substance Painter.
- Efectos de part√≠culas personalizados.
- Audio: FMOD Studio para m√∫sica adaptativa.
- Efectos Visuales: Unity VFX Graph.

## üîß Requisitos T√©cnicos
- Unity 2022.3 o superior.
- Paquetes requeridos:
  - Universal RP
  - Cinemachine
  - Post Processing
  - Input System
  - TextMeshPro

## üöÄ Instalaci√≥n
1. Clonar el repositorio.
2. Abrir con Unity 2022.3 o superior.
3. Instalar los paquetes requeridos desde el Package Manager.
4. Abrir la escena principal en `Assets/Scenes`.

## üìú Licencia
Este proyecto est√° bajo la Licencia MIT. Ver LICENSE.md para m√°s detalles.

## ü§ù Contribuciones
Las contribuciones son bienvenidas. Por favor, revisa CONTRIBUTING.md para las gu√≠as de estilo y proceso.

## üéÆ Versi√≥n del Juego
Versi√≥n 1.0.0

## üë®‚Äçüíª Autor
[Idafe Cabrera Toledo]

## Tutoriales de ayuda
Curso en udemy
Unity 6 y C# Desarrollo de Videojuegos + Unity Muse IA
Curso de fundamentos de Unity donde abordaremos todas las √°reas de desarrollo desde cero iniciando por los fundamentos
Creado por Casta Tutors

## üë®‚Äçüíª Tutor 
Tiburcio Cruz Ravelo

